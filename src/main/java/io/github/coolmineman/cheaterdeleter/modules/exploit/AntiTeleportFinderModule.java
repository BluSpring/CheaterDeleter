package io.github.coolmineman.cheaterdeleter.modules.exploit;

import java.util.concurrent.ThreadLocalRandom;

import io.github.coolmineman.cheaterdeleter.events.OutgoingPacketListener;
import io.github.coolmineman.cheaterdeleter.modules.CDModule;
import io.github.coolmineman.cheaterdeleter.objects.MutableEntityPositionS2CPacket;
import io.github.coolmineman.cheaterdeleter.objects.entity.CDPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.listener.ClientPlayPacketListener;

public class AntiTeleportFinderModule extends CDModule implements OutgoingPacketListener {
    public AntiTeleportFinderModule() {
        super("antiteleport_finder");
        OutgoingPacketListener.EVENT.register(this);
    }

    @Override
    public void onOutgoingPacket(CDPlayer player, Packet<ClientPlayPacketListener> packet) {
        if (!enabledFor(player)) return;
        if (packet instanceof MutableEntityPositionS2CPacket) {
            MutableEntityPositionS2CPacket packet2 = (MutableEntityPositionS2CPacket) packet;
            int viewDistance = player.asMcPlayer().server.getPlayerManager().getViewDistance();
            int maxDistance = (int)(viewDistance * 16 * 1.5);
            if (Math.abs(player.getPacketX() - packet2.getX()) > maxDistance || Math.abs(player.getPacketZ() - packet2.getZ()) > maxDistance) {
                scrambleTeleportPacket(player, viewDistance, packet2);
            }
        }
    }

    private void scrambleTeleportPacket(CDPlayer player, int viewDistance, MutableEntityPositionS2CPacket packet) {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        packet.setX(getFakeDouble(random, player.getPacketX(), (double) viewDistance + 16, 50000));
        packet.setY(random.nextDouble() * 256.0);
        packet.setZ(getFakeDouble(random, player.getPacketZ(), (double) viewDistance + 16, 50000));
    }

    private double getFakeDouble(ThreadLocalRandom random, double origin, double lowerdeltabound, double upperdeltabound) {
        double a = ((random.nextDouble() - 0.5) * 2 * (upperdeltabound - lowerdeltabound));
        return origin + (a > 0 ? a + lowerdeltabound : a - lowerdeltabound);
    }
}
